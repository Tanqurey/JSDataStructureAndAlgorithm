/*
算法的时间复杂度，
用来度量算法的运行时间，记作: T(n) = O(f(n))。
它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。

时间复杂度的分析策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。

1.
时间复杂度的计算

1)
我们知道常数项对函数的增长速度影响并不大，
所以当 T(n) = c，c 为一个常数的时候，
我们说这个算法的时间复杂度为 O(1)；
如果 T(n) 不等于一个常数项时，直接将常数项省略。
*/

function print(word) {
  console.log(word)
  console.log(word)
  // 共执行两次，O(1)
}

/*
2)我们知道高次项对于函数的增长速度的影响是最大的。
n^3 的增长速度是远超 n^2 的，
同时 n^2 的增长速度是远超 n 的。 
同时因为要求的精度不高，所以我们直接忽略低于此项的项。

3)因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。

总结：综合起来：如果一个算法的执行次数是 T(n)，
那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，
此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。


典型例题：
1.对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个
循环的时间复杂度为 O(n×m)。

2.对于多个循环，假设循环体的时间复杂度为 O(n)，
各个循环的循环次数分别是a, b, c...，
则这个循环的时间复杂度为 O(n×a×b×c...)。
分析的时候应该由里向外分析这些循环。
*/

for (let i = 0; i < m; i++) { //m
  for (let k = 0; k < n; k++) { //n
    for (let j = 0; j < l; j++) { //l
      console.log(j) // 循环体的时间复杂度为1
    }
  }
}
/*
时间复杂度为
O(1*l*n*m)

3.对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。
4.对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。

练习题：
*/

for (let i = 0; i < n; i++) {
  for (let j = i; j < n; j++) {
    console.log("Hello World\n");
  }
}
/*
执行次数为：n + n-1 + n-2 + ... + 1
根据等差数列求和公式：
T(n)= n*(n-1)/2
O(n)=n^2


*/

for (let i = 2; i < n; i++) {
  i *= 2;
  printf("%i\n", i);
}
/*
设循环次数为t
则有2^t<n
t<=log(2)n
时间复杂度为logn
*/